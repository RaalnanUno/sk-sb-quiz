[
  {
    "domain": "Observability: Dynatrace vs Azure Monitor",
    "lesson": "Dynatrace is a dedicated full-stack observability and APM platform, while Azure Monitor is a cloud-native monitoring service specific to Azure.",
    "question": "What’s a key difference between Dynatrace and Azure Monitor?",
    "correctAnswer": "Dynatrace provides full-stack observability across multi-cloud and hybrid environments",
    "dummyAnswers": [
      "Azure Monitor only provides logs with no performance metrics",
      "Dynatrace replaces Azure hosting entirely",
      "Azure Monitor requires on-prem servers to work"
    ]
  },
  {
    "domain": "Observability: Tool Selection",
    "lesson": "Datadog, New Relic, and AppDynamics are common Dynatrace alternatives for APM and distributed tracing.",
    "question": "Which of the following is a common alternative to Dynatrace?",
    "correctAnswer": "Datadog",
    "dummyAnswers": [
      "Veracode",
      "MSTest",
      "Fortify"
    ]
  },
  {
    "domain": ".NET Core Development",
    "question": "What advantage does .NET Core provide when building modern backend services?",
    "correctAnswer": "Cross-platform support and performance optimized for cloud and microservices",
    "dummyAnswers": [
      "It can only run on Windows servers for maximum security",
      "It automatically scales up memory without configuration",
      "It eliminates the need to write controllers for APIs"
    ]
  },
  {
    "domain": "Node.js Fundamentals",
    "question": "Why might a team choose Node.js for building APIs?",
    "correctAnswer": "Its event-driven, non-blocking model handles I/O efficiently",
    "dummyAnswers": [
      "It compiles directly to native machine code",
      "It automatically provides strict type checking",
      "It includes a relational database built into the runtime"
    ]
  },
  {
    "domain": "RESTful API Design",
    "question": "What is a best practice when designing RESTful endpoints?",
    "correctAnswer": "Use resource-based URLs and proper HTTP status codes",
    "dummyAnswers": [
      "Always return HTTP 200, even for failures",
      "Include version numbers in every query parameter",
      "Use verbs in URLs for clarity, like /UpdateCustomer"
    ]
  },
  {
    "domain": "SQL Server",
    "question": "What is the purpose of using database indexes?",
    "correctAnswer": "To speed up data retrieval by reducing the amount of scanned rows",
    "dummyAnswers": [
      "To store encrypted data only",
      "To automatically back up tables on interval",
      "To force every query to run in serial mode"
    ]
  },
  {
    "domain": "Azure DevOps CI/CD",
    "question": "What does a CI pipeline primarily ensure?",
    "correctAnswer": "Each commit is validated through automated build and test steps",
    "dummyAnswers": [
      "Only production deployments are logged",
      "Developers must manually approve every unit test",
      "All builds are executed directly on local developer machines"
    ]
  },
  {
    "domain": "Docker",
    "question": "Why are Docker containers useful in application delivery?",
    "correctAnswer": "They ensure consistency by packaging the app and its dependencies together",
    "dummyAnswers": [
      "They replace the need for cloud hosting entirely",
      "They force apps to run faster than virtual machines",
      "They allow deployments without any version control"
    ]
  },
  {
    "domain": "Secure Coding",
    "question": "Why do organizations use tools like Veracode?",
    "correctAnswer": "To detect security vulnerabilities in the code before deployment",
    "dummyAnswers": [
      "To automatically rewrite application code using AI",
      "To handle user authentication and authorization",
      "To compress all build artifacts for faster deployment"
    ]
  },
  {
    "domain": "Monitoring & Observability",
    "question": "What does Dynatrace primarily help with?",
    "correctAnswer": "Monitoring application performance and detecting production issues",
    "dummyAnswers": [
      "Replacing SQL queries with NoSQL alternatives",
      "Enforcing deployment approvals in Azure DevOps",
      "Encrypting stored credentials inside the app"
    ]
  },
  {
    "domain": "Architecture",
    "question": "What is a key benefit of modular application architecture?",
    "correctAnswer": "It allows components to be developed, deployed, and scaled independently",
    "dummyAnswers": [
      "It requires fewer developers to collaborate on features",
      "It prevents network calls between services completely",
      "It eliminates the need for API contracts"
    ]
  },
  {
    "domain": "Automation",
    "question": "Why is automation important in DevOps?",
    "correctAnswer": "It reduces manual errors and accelerates delivery pipelines",
    "dummyAnswers": [
      "It removes the need for testing entirely",
      "It ensures deployments only happen once per month",
      "It makes debugging impossible during builds"
    ]
  },
  {
    "domain": "Svelte: Lifecycle",
    "lesson": "onMount runs only in the browser after the component is first rendered, and is the right place for client-only code like fetch or localStorage.",
    "question": "What is the primary purpose of Svelte's onMount lifecycle function?",
    "correctAnswer": "Run client-side code after the component first renders.",
    "dummyAnswers": [
      "To run code before TypeScript compiles the component",
      "To control how often the component re-renders on state changes",
      "To statically analyze the component during Svelte's build step"
    ]
  },
  {
    "domain": "Svelte: Reactivity Basics",
    "lesson": "In Svelte, reassigning a variable triggers reactive updates; you don’t call setState like in React.",
    "question": "How do you typically trigger a reactive update in Svelte?",
    "correctAnswer": "Reassign a local variable so Svelte detects the change.",
    "dummyAnswers": [
      "By calling setState() with the new value",
      "By calling forceUpdate() after modifying the value",
      "By wrapping the value in a useEffect callback"
    ]
  },
  {
    "domain": "Svelte: Reactive Statements",
    "lesson": "Reactive declarations using the $: syntax recompute whenever their dependencies change.",
    "question": "What does a Svelte reactive statement using the '$:' syntax do?",
    "correctAnswer": "Recomputes its expression when its referenced values change.",
    "dummyAnswers": [
      "It runs only once, when the component first mounts",
      "It registers a watcher that must be manually cleaned up",
      "It defines a global variable that can be shared across components"
    ]
  },
  {
    "domain": "Svelte: Conditional Rendering",
    "lesson": "{#if}{:else if}{:else}{/if} blocks control which parts of the template are rendered based on state.",
    "question": "What is the purpose of the {#if}{:else}{/if} block in Svelte templates?",
    "correctAnswer": "Conditionally render markup based on a boolean expression.",
    "dummyAnswers": [
      "To define a new component that can be reused elsewhere",
      "To delay rendering until all promises have resolved",
      "To memoize a section of the template for performance"
    ]
  },
  {
    "domain": "Svelte: Each Blocks",
    "lesson": "{#each} blocks let you loop over arrays and render list items directly in the template.",
    "question": "How do you render a list of items from an array in Svelte?",
    "correctAnswer": "Use a {#each array as item}{/each} block in the markup.",
    "dummyAnswers": [
      "By calling array.map() directly inside a <script> block",
      "By wrapping the array in a special List component",
      "By using a v-for directive on each list element"
    ]
  },
  {
    "domain": "Svelte: Event Handling",
    "lesson": "Svelte attaches DOM event listeners using the on:eventName directive, such as on:click.",
    "question": "How do you attach a click handler to a button in Svelte?",
    "correctAnswer": "Use on:click={yourHandler} on the button.",
    "dummyAnswers": [
      "Use @click=\"yourHandler\" on the button element",
      "Call addEventListener inside onMount for each button",
      "Use onclick={yourHandler} in the <script> block"
    ]
  },
  {
    "domain": "Svelte: Two-Way Binding",
    "lesson": "bind:value enables two-way data binding between form controls and component state.",
    "question": "What does bind:value={foo} do on an <input> element in Svelte?",
    "correctAnswer": "Keeps the input value and foo variable in sync.",
    "dummyAnswers": [
      "It only sets the input’s initial value from foo but does not update it",
      "It only updates foo when the component first mounts",
      "It disables manual updates to the input’s value"
    ]
  },
  {
    "domain": "Svelte: Stores vs Local State",
    "lesson": "Local variables in a Svelte component are component-scoped, while stores are shared reactive values that can be used across components.",
    "question": "How does using a Svelte store differ from using a local let variable in a component?",
    "correctAnswer": "Provides shared reactive values used across multiple components.",
    "dummyAnswers": [
      "Stores are compiled away, while local variables remain at runtime",
      "Stores can only be used in onMount, not in normal component code",
      "Stores are required for all state in Svelte components"
    ]
  },
  {
    "domain": "Svelte: Asynchronous Data",
    "lesson": "Fetching data inside onMount ensures the code runs only in the browser, avoiding errors during server-side rendering.",
    "question": "Why is it common to perform fetch requests inside onMount in a Svelte component?",
    "correctAnswer": "Because onMount runs only in the browser, not during SSR.",
    "dummyAnswers": [
      "Because Svelte cannot import async functions in the <script> block",
      "Because fetch can only be called from lifecycle hooks",
      "Because Svelte automatically retries fetch calls only when used in onMount"
    ]
  },
  {
    "domain": "Svelte: Re-rendering Logic",
    "lesson": "Svelte tracks which variables change and only updates the parts of the DOM that depend on them.",
    "question": "How does Svelte decide which parts of the DOM to update when state changes?",
    "correctAnswer": "Updates only template parts that depend on changed variables.",
    "dummyAnswers": [
      "It always re-renders the entire component tree from the root",
      "It uses a virtual DOM diff algorithm like React",
      "It manually compares previous and next props for every component"
    ]
  },
  {
    "domain": "React: State Initialization",
    "lesson": "Lazy initialization for useState lets you compute initial state once during mount, avoiding unnecessary effects.",
    "question": "Why is a lazy initializer a better place than useEffect to read from localStorage?",
    "correctAnswer": "Because the initializer runs once at mount without causing extra renders or violating React effect rules",
    "dummyAnswers": [
      "Because useEffect cannot read from localStorage",
      "Because lazy initializers automatically sync state with external systems",
      "Because useEffect runs before the component is created"
    ]
  },
  {
    "domain": "TypeScript: Avoiding any",
    "lesson": "Casting to a specific type preserves type safety while casting to any disables it.",
    "question": "Why should you avoid using 'as any' in TypeScript?",
    "correctAnswer": "It removes type safety and causes linter errors like 'Unexpected any'",
    "dummyAnswers": [
      "'as any' makes your app run slower",
      "'as any' is deprecated and will be removed in future TypeScript versions",
      "'as any' prevents your code from compiling entirely"
    ]
  },
  {
    "domain": "Next.js: Server vs Client Components",
    "lesson": "Client components can use browser APIs like localStorage; server components cannot.",
    "question": "Why must ContactInfoLine be a client component?",
    "correctAnswer": "Because it reads from localStorage, which only exists in the browser",
    "dummyAnswers": [
      "Because all components must be client components",
      "Because server components cannot import JSON files",
      "Because client components render faster"
    ]
  },
  {
    "domain": "TypeScript: typeof JSON Typing",
    "lesson": "Using typeof for JSON imports gives you a fully inferred static type.",
    "question": "What does 'type ResumeData = typeof resumeData' achieve?",
    "correctAnswer": "It creates a type based on the structure of the imported JSON",
    "dummyAnswers": [
      "It converts JSON data into a class",
      "It ensures the JSON cannot be modified",
      "It tells TypeScript to ignore JSON validation"
    ]
  },
  {
    "domain": "React Effects",
    "lesson": "Effects should synchronize React with external systems, not initialize state.",
    "question": "What is the main reason React warns about calling setState inside an effect for initialization?",
    "correctAnswer": "It can cause unnecessary re-renders and violates React’s recommended effect usage",
    "dummyAnswers": [
      "Effects cannot call setState under any circumstances",
      "Effects always run synchronously before rendering",
      "Effects should only be used for DOM manipulation"
    ]
  },
  {
    "domain": "localStorage Safety",
    "lesson": "localStorage is not available on the server, so components must guard against SSR.",
    "question": "Why do we check 'typeof window === \"undefined\"' before reading localStorage?",
    "correctAnswer": "Because server-rendered code runs without a window object",
    "dummyAnswers": [
      "Because window becomes undefined after hydration",
      "Because localStorage sometimes returns null",
      "Because checking window improves rendering performance"
    ]
  },
  {
    "domain": "TypeScript Narrowing",
    "lesson": "Validating unknown JSON objects prevents runtime errors.",
    "question": "Why do we check 'typeof parsed === \"object\"' before merging it into state?",
    "correctAnswer": "To ensure the JSON parsed value is safe to use as an object",
    "dummyAnswers": [
      "Because JSON.parse sometimes returns arrays",
      "Because TypeScript requires all values to be objects",
      "Because objects are faster for React to update"
    ]
  },
  {
    "domain": "React State Design",
    "lesson": "Derived state should be computed once and not kept in sync automatically unless necessary.",
    "question": "Why do we not auto-update contact info in state when localStorage changes?",
    "correctAnswer": "Because contact info is meant to be loaded once at mount and doesn’t need live syncing",
    "dummyAnswers": [
      "Because React cannot detect changes in localStorage",
      "Because localStorage events are disabled in Next.js",
      "Because merging state multiple times causes infinite loops"
    ]
  },
  {
    "domain": "TypeScript Structural Types",
    "lesson": "A value satisfies a type if it includes at least the required fields.",
    "question": "Why is it safe to cast JSON contact data to the ContactInfo type?",
    "correctAnswer": "Because the JSON has the same required fields defined in ContactInfo",
    "dummyAnswers": [
      "Because TypeScript automatically validates JSON at runtime",
      "Because casting converts the JSON into a class instance",
      "Because all TypeScript types are enforced at runtime"
    ]
  },
  {
    "domain": "React Best Practices",
    "lesson": "State that never changes after mount should not use setters in effects.",
    "question": "After refactoring, why does ContactInfoLine no longer use setState in an effect?",
    "correctAnswer": "Because the localStorage override is applied once through a lazy initializer instead",
    "dummyAnswers": [
      "Because React hooks cannot be used in effects",
      "Because effects are slower than state initializers",
      "Because useState cannot store objects without an initializer"
    ]
  }
]