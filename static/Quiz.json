[
  {
    "domain": "Svelte: Lifecycle",
    "lesson": "onMount runs only in the browser after the component is first rendered, and is the right place for client-only code like fetch or localStorage.",
    "question": "What is the primary purpose of Svelte's onMount lifecycle function?",
    "correctAnswer": "Run client-side code after the component first renders.",
    "dummyAnswers": [
      "To run code before TypeScript compiles the component",
      "To control how often the component re-renders on state changes",
      "To statically analyze the component during Svelte's build step"
    ]
  },
  {
    "domain": "Svelte: Reactivity Basics",
    "lesson": "In Svelte, reassigning a variable triggers reactive updates; you don’t call setState like in React.",
    "question": "How do you typically trigger a reactive update in Svelte?",
    "correctAnswer": "Reassign a local variable so Svelte detects the change.",
    "dummyAnswers": [
      "By calling setState() with the new value",
      "By calling forceUpdate() after modifying the value",
      "By wrapping the value in a useEffect callback"
    ]
  },
  {
    "domain": "Svelte: Reactive Statements",
    "lesson": "Reactive declarations using the $: syntax recompute whenever their dependencies change.",
    "question": "What does a Svelte reactive statement using the '$:' syntax do?",
    "correctAnswer": "Recomputes its expression when its referenced values change.",
    "dummyAnswers": [
      "It runs only once, when the component first mounts",
      "It registers a watcher that must be manually cleaned up",
      "It defines a global variable that can be shared across components"
    ]
  },
  {
    "domain": "Svelte: Conditional Rendering",
    "lesson": "{#if}{:else if}{:else}{/if} blocks control which parts of the template are rendered based on state.",
    "question": "What is the purpose of the {#if}{:else}{/if} block in Svelte templates?",
    "correctAnswer": "Conditionally render markup based on a boolean expression.",
    "dummyAnswers": [
      "To define a new component that can be reused elsewhere",
      "To delay rendering until all promises have resolved",
      "To memoize a section of the template for performance"
    ]
  },
  {
    "domain": "Svelte: Each Blocks",
    "lesson": "{#each} blocks let you loop over arrays and render list items directly in the template.",
    "question": "How do you render a list of items from an array in Svelte?",
    "correctAnswer": "Use a {#each array as item}{/each} block in the markup.",
    "dummyAnswers": [
      "By calling array.map() directly inside a <script> block",
      "By wrapping the array in a special List component",
      "By using a v-for directive on each list element"
    ]
  },
  {
    "domain": "Svelte: Event Handling",
    "lesson": "Svelte attaches DOM event listeners using the on:eventName directive, such as on:click.",
    "question": "How do you attach a click handler to a button in Svelte?",
    "correctAnswer": "Use on:click={yourHandler} on the button.",
    "dummyAnswers": [
      "Use @click=\"yourHandler\" on the button element",
      "Call addEventListener inside onMount for each button",
      "Use onclick={yourHandler} in the <script> block"
    ]
  },
  {
    "domain": "Svelte: Two-Way Binding",
    "lesson": "bind:value enables two-way data binding between form controls and component state.",
    "question": "What does bind:value={foo} do on an <input> element in Svelte?",
    "correctAnswer": "Keeps the input value and foo variable in sync.",
    "dummyAnswers": [
      "It only sets the input’s initial value from foo but does not update it",
      "It only updates foo when the component first mounts",
      "It disables manual updates to the input’s value"
    ]
  },
  {
    "domain": "Svelte: Stores vs Local State",
    "lesson": "Local variables in a Svelte component are component-scoped, while stores are shared reactive values that can be used across components.",
    "question": "How does using a Svelte store differ from using a local let variable in a component?",
    "correctAnswer": "Provides shared reactive values used across multiple components.",
    "dummyAnswers": [
      "Stores are compiled away, while local variables remain at runtime",
      "Stores can only be used in onMount, not in normal component code",
      "Stores are required for all state in Svelte components"
    ]
  },
  {
    "domain": "Svelte: Asynchronous Data",
    "lesson": "Fetching data inside onMount ensures the code runs only in the browser, avoiding errors during server-side rendering.",
    "question": "Why is it common to perform fetch requests inside onMount in a Svelte component?",
    "correctAnswer": "Because onMount runs only in the browser, not during SSR.",
    "dummyAnswers": [
      "Because Svelte cannot import async functions in the <script> block",
      "Because fetch can only be called from lifecycle hooks",
      "Because Svelte automatically retries fetch calls only when used in onMount"
    ]
  },
  {
    "domain": "Svelte: Re-rendering Logic",
    "lesson": "Svelte tracks which variables change and only updates the parts of the DOM that depend on them.",
    "question": "How does Svelte decide which parts of the DOM to update when state changes?",
    "correctAnswer": "Updates only template parts that depend on changed variables.",
    "dummyAnswers": [
      "It always re-renders the entire component tree from the root",
      "It uses a virtual DOM diff algorithm like React",
      "It manually compares previous and next props for every component"
    ]
  },
  {
    "domain": "React: State Initialization",
    "lesson": "Lazy initialization for useState lets you compute initial state once during mount, avoiding unnecessary effects.",
    "question": "Why is a lazy initializer a better place than useEffect to read from localStorage?",
    "correctAnswer": "Because the initializer runs once at mount without causing extra renders or violating React effect rules",
    "dummyAnswers": [
      "Because useEffect cannot read from localStorage",
      "Because lazy initializers automatically sync state with external systems",
      "Because useEffect runs before the component is created"
    ]
  },
  {
    "domain": "TypeScript: Avoiding any",
    "lesson": "Casting to a specific type preserves type safety while casting to any disables it.",
    "question": "Why should you avoid using 'as any' in TypeScript?",
    "correctAnswer": "It removes type safety and causes linter errors like 'Unexpected any'",
    "dummyAnswers": [
      "'as any' makes your app run slower",
      "'as any' is deprecated and will be removed in future TypeScript versions",
      "'as any' prevents your code from compiling entirely"
    ]
  },
  {
    "domain": "Next.js: Server vs Client Components",
    "lesson": "Client components can use browser APIs like localStorage; server components cannot.",
    "question": "Why must ContactInfoLine be a client component?",
    "correctAnswer": "Because it reads from localStorage, which only exists in the browser",
    "dummyAnswers": [
      "Because all components must be client components",
      "Because server components cannot import JSON files",
      "Because client components render faster"
    ]
  },
  {
    "domain": "TypeScript: typeof JSON Typing",
    "lesson": "Using typeof for JSON imports gives you a fully inferred static type.",
    "question": "What does 'type ResumeData = typeof resumeData' achieve?",
    "correctAnswer": "It creates a type based on the structure of the imported JSON",
    "dummyAnswers": [
      "It converts JSON data into a class",
      "It ensures the JSON cannot be modified",
      "It tells TypeScript to ignore JSON validation"
    ]
  },
  {
    "domain": "React Effects",
    "lesson": "Effects should synchronize React with external systems, not initialize state.",
    "question": "What is the main reason React warns about calling setState inside an effect for initialization?",
    "correctAnswer": "It can cause unnecessary re-renders and violates React’s recommended effect usage",
    "dummyAnswers": [
      "Effects cannot call setState under any circumstances",
      "Effects always run synchronously before rendering",
      "Effects should only be used for DOM manipulation"
    ]
  },
  {
    "domain": "localStorage Safety",
    "lesson": "localStorage is not available on the server, so components must guard against SSR.",
    "question": "Why do we check 'typeof window === \"undefined\"' before reading localStorage?",
    "correctAnswer": "Because server-rendered code runs without a window object",
    "dummyAnswers": [
      "Because window becomes undefined after hydration",
      "Because localStorage sometimes returns null",
      "Because checking window improves rendering performance"
    ]
  },
  {
    "domain": "TypeScript Narrowing",
    "lesson": "Validating unknown JSON objects prevents runtime errors.",
    "question": "Why do we check 'typeof parsed === \"object\"' before merging it into state?",
    "correctAnswer": "To ensure the JSON parsed value is safe to use as an object",
    "dummyAnswers": [
      "Because JSON.parse sometimes returns arrays",
      "Because TypeScript requires all values to be objects",
      "Because objects are faster for React to update"
    ]
  },
  {
    "domain": "React State Design",
    "lesson": "Derived state should be computed once and not kept in sync automatically unless necessary.",
    "question": "Why do we not auto-update contact info in state when localStorage changes?",
    "correctAnswer": "Because contact info is meant to be loaded once at mount and doesn’t need live syncing",
    "dummyAnswers": [
      "Because React cannot detect changes in localStorage",
      "Because localStorage events are disabled in Next.js",
      "Because merging state multiple times causes infinite loops"
    ]
  },
  {
    "domain": "TypeScript Structural Types",
    "lesson": "A value satisfies a type if it includes at least the required fields.",
    "question": "Why is it safe to cast JSON contact data to the ContactInfo type?",
    "correctAnswer": "Because the JSON has the same required fields defined in ContactInfo",
    "dummyAnswers": [
      "Because TypeScript automatically validates JSON at runtime",
      "Because casting converts the JSON into a class instance",
      "Because all TypeScript types are enforced at runtime"
    ]
  },
  {
    "domain": "React Best Practices",
    "lesson": "State that never changes after mount should not use setters in effects.",
    "question": "After refactoring, why does ContactInfoLine no longer use setState in an effect?",
    "correctAnswer": "Because the localStorage override is applied once through a lazy initializer instead",
    "dummyAnswers": [
      "Because React hooks cannot be used in effects",
      "Because effects are slower than state initializers",
      "Because useState cannot store objects without an initializer"
    ]
  }
]